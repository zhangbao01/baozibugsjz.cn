[{"title":"Hexo搭建","url":"/2021/09/25/Hexo%E6%90%AD%E5%BB%BA/","content":"安装node.js添加国内镜像$ npm config set registry https://registry.npm.taobao.org\n\n安装Git安装Hexo创建一个目录，打开 Git Bash Here\n安装全局Hexo$ npm i hexo-cli -g\n\n\ni 是 install，hexo-cli 是 hexoclient，-g 是全局。\n\n初始化文件夹$ hexo init\n\n生成静态页面$ hexo g\n\n打开本地服务器$ hexo s\n\n访问 http://localhost:4000/ 可以看到本地结果\n连接Github与本地修改配置打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。\n$ deploy:  type: git  repo: https://github.com/zhangbao01/zhangbao.github.io.git  branch: main\n安装hexo git插件$ npm i hexo-deployer-git\n上传github$ hexo d\n\n编写完markdown文件后，将文件保存到\\source\\_posts目录下，在根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。然后访问zhangbao01.github.io，前缀必须和GitHub账户名一致，不然会报404。绑定域名在settings里。\n\n"},{"title":"Hello World","url":"/2021/06/24/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Docker","url":"/2021/09/25/Docker/","content":"docker运行java安装java镜像$ docker pull java\n确认是否安装成功$ docker images\n配置Dockerfile自定义目录  创建 Dockerfile 文件\n$ FROM java:8  MAINTAINER baozi  ADD script-0.0.1-SNAPSHOT.jar stock_script.jar  EXPOSE 10000  ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;stock_script.jar&quot;]\n\nFROM指定基础镜像，必须是第一，这里指定的java，冒号后面是版本\nMAINTAINER 维护者信息\nADD将本地文件添加到镜像中，后面是别名\nEXPOSE指定外界交互端口\nENTRYPOINT配置容器，使其可执行化，也可以用CMD构建镜像$ docker build -t stock_script .\n-t或--tag镜像的名字及标签\n末尾的.表示当前文件夹下的Dockerfile启动镜像$  docker run -d --restart=always --name stock_company --network host -p 10000:10000  stock_company \n-d表示后台运行\n--restart重启的时候自动运行\n--name重命名\n--network指定网卡，注意：不加会导致多docker服务不能相互通信\n-p指定端口映射查看容器运行状态$ docker ps\n查看所有容器$ docker ps -a\n查看容器日志先通过 docker ps获取容器id$ docker logs 容器Id\n停止/启动容器$ docker stop 容器Id$ docker start 容器Id\n删除容器$ docker rm 容器Id\n删除镜像$ docker rmi 镜像Id\n\n"},{"title":"Linux 安装 Java","url":"/2021/09/25/Linux-%E5%AE%89%E8%A3%85-Java/","content":"CentOS上传安装包或自行下载地址: https://www.oracle.com/cn/java/technologies/javase/javase-jdk8-downloads.html\n创建安装文件夹$ mkdir /usr/local/java/\n解压安装$ tar -zxvf jdk-8u291-linux-x64.tar.gz -C /usr/local/java/\n编辑配置环境文件$ vim /etc/profile\n文件末尾添加$ export JAVA_HOME=/usr/local/java/jdk1.8.0_291$ export JRE_HOME=$&#123;JAVA_HOME&#125;/jre$ export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib$ export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH\n生效修改$ source /etc/profile\n\nsource相当于把profile里面的环境变量加载出来，相当于.。如果不用source 选择重新打开shell窗口依然可以加载出来，是因为profile是系统的配置文件，每打开一个shell会自动加载。\n当然你也可以选择在任意文件加以上变量，然后用source加载出来都可以使用，只不过不是系统文件重新打开不会自动加载\n关闭shell后所有环境变量都会被释放。校验$ java -version\n直接运行jar$ nohup java -jar company-0.0.1-SNAPSHOT.jar &gt;log.txt &amp;\nnohup挂起运行&gt;输出文件&amp;后台运行\n\n挂起nohup和后台&amp;区别"},{"title":"Linux挂载分区","url":"/2021/09/25/Linux%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BA/","content":"查看硬盘已挂载[root@VM_0_9_centos ~]# df -h Filesystem      Size  Used Avail Use% Mounted on/dev/vda1        50G   18G   29G  39% /devtmpfs        3.9G     0  3.9G   0% /devtmpfs           3.9G     0  3.9G   0% /dev/shmtmpfs           3.9G  696K  3.9G   1% /runtmpfs           3.9G     0  3.9G   0% /sys/fs/cgrouptmpfs           783M     0  783M   0% /run/user/0\n所有[root@VM_0_9_centos ~]# fdisk -lDisk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x0009ac89   Device Boot      Start         End      Blocks   Id  System/dev/vda1   *        2048   104857599    52427776   83  LinuxDisk /dev/vdb: 107.4 GB, 107374182400 bytes, 209715200 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes\n需要挂载的是/dev/vdb\n找到硬盘分区格式化磁盘分区[root@VM_0_9_centos ~]# fdisk /dev/vdb       //进入磁盘Welcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0x5e70f310.Command (m for help): p\t                    //查看已有分区Disk /dev/vdb: 107.4 GB, 107374182400 bytes, 209715200 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x5e70f310   Device Boot      Start         End      Blocks   Id  SystemCommand (m for help): n                    //创建分区Partition type:   p   primary (0 primary, 0 extended, 4 free)   e   extendedSelect (default p): p                      //主分区Partition number (1-4, default 1): First sector (2048-209715199, default 2048): Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-209715199, default 209715199): Using default value 209715199Partition 1 of type Linux and of size 100 GiB is setCommand (m for help): p                   //查看确认主分区Disk /dev/vdb: 107.4 GB, 107374182400 bytes, 209715200 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x5e70f310   Device Boot      Start         End      Blocks   Id  System/dev/vdb1            2048   209715199   104856576   83  LinuxCommand (m for help): w                    //保存修改The partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.\n分区格式化必须格式化，不然拿不到UUID\n[root@VM_0_9_centos ~]# mkfs.xfs /dev/vdb1 meta-data=/dev/vdb1              isize=512    agcount=4, agsize=6553536 blks         =                       sectsz=512   attr=2, projid32bit=1         =                       crc=1        finobt=0, sparse=0data     =                       bsize=4096   blocks=26214144, imaxpct=25         =                       sunit=0      swidth=0 blksnaming   =version 2              bsize=4096   ascii-ci=0 ftype=1log      =internal log           bsize=4096   blocks=12799, version=2         =                       sectsz=512   sunit=0 blks, lazy-count=1realtime =none                   extsz=4096   blocks=0, rtextents=0\n查看检查分区[root@VM_0_9_centos ~]# lsblkNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsr0     11:0    1 37.7M  0 rom  vda    253:0    0   50G  0 disk └─vda1 253:1    0   50G  0 part /vdb    253:16   0  100G  0 disk └─vdb1 253:17   0  100G  0 part \n挂载分区到”/home”查看UUID，写入fstab[root@VM_0_9_centos ~]# blkid /dev/vdb1 /dev/vdb1: UUID=&quot;0e1577b6-52df-49c7-8ea3-1d1a83e71809&quot; TYPE=&quot;xfs&quot; \n编辑fstab$ vim /etc/fstab\n尾行添加UUID=0e1577b6-52df-49c7-8ea3-1d1a83e71809            /home xfs defaults    0 0 \n重新读取配置文件$ mount -a \n查看结果[root@VM_0_9_centos home]# df -hFilesystem      Size  Used Avail Use% Mounted on/dev/vda1        50G   18G   29G  39% /devtmpfs        3.9G     0  3.9G   0% /devtmpfs           3.9G     0  3.9G   0% /dev/shmtmpfs           3.9G  724K  3.9G   1% /runtmpfs           3.9G     0  3.9G   0% /sys/fs/cgrouptmpfs           783M     0  783M   0% /run/user/0/dev/vdb1       100G   33M  100G   1% /home"},{"title":"HashMap源码put （链存储）","url":"/2021/12/12/HashMap%E6%BA%90%E7%A0%81put%EF%BC%88%E9%93%BE%E5%AD%98%E5%82%A8%EF%BC%89/","content":"概述本篇主要讲述jdk1.8 hashmap链式存储的源码流程，和作者认为比较亮眼的地方\n\nputpublic V put(K key, V value) &#123;        return putVal(hash(key), key, value, false, true);    &#125;\nhashstatic final int hash(Object key) &#123;        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    &#125;\n这个是对key做hashcode处理，将hashcode右移16位原hashcode做一次异或(^)运算由于计算key所在数组位置，是通过key的hashcode和数组长度减一做的与(&amp;)运算tab[i = (n - 1) &amp; hash]所以高位在大多数情况下都是用不到的，右移16位是为了让高位参与到数组位置的计算。当然如果这个key算出来小于16位且大于数组长度，还是会有部分用不到的。异或(^)，本身计算，相同为0，不同为1，1^0有四种情况（11，10，01，00），但是结果为1或者0的概率是相等的，并不会出现偏向1或偏向0的情况。\nputValfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else &#123;            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else &#123;                for (int binCount = 0; ; ++binCount) &#123;                    if ((e = p.next) == null) &#123;                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    &#125;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                &#125;            &#125;            if (e != null) &#123; // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            &#125;        &#125;        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    &#125;\n这个方法判断了有没有链表，是不是红黑树，即后续处理主要说一下tab[i = (n - 1) &amp; hash]首先与(&amp;)操作，a&amp;b，当ab同时为1时，结果才为1，其他情况下为0，在1和0四种情况中，很明显是偏向于0的，但是hashmap初始长度是16二进制是10000，n-1的结果就是15``1111，a&amp;1111结果只是取了a的后四位，并没有出现概率偏差的情况。所以hashmap的扩容是以左移一个单位，为了保证n-1的结果位数全部是1的情况\nresizefinal Node&lt;K,V&gt;[] resize() &#123;        Node&lt;K,V&gt;[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;        int oldThr = threshold;        int newCap, newThr = 0;        if (oldCap &gt; 0) &#123;            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;                threshold = Integer.MAX_VALUE;                return oldTab;            &#125;            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                newThr = oldThr &lt;&lt; 1; // double threshold        &#125;        else if (oldThr &gt; 0) // initial capacity was placed in threshold            newCap = oldThr;        else &#123;               // zero initial threshold signifies using defaults            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        &#125;        if (newThr == 0) &#123;            float ft = (float)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        &#125;        threshold = newThr;        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];        table = newTab;        if (oldTab != null) &#123;            for (int j = 0; j &lt; oldCap; ++j) &#123;                Node&lt;K,V&gt; e;                if ((e = oldTab[j]) != null) &#123;                    oldTab[j] = null;                    if (e.next == null)                        newTab[e.hash &amp; (newCap - 1)] = e;                    else if (e instanceof TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    else &#123; // preserve order                        Node&lt;K,V&gt; loHead = null, loTail = null;                        Node&lt;K,V&gt; hiHead = null, hiTail = null;                        Node&lt;K,V&gt; next;                        do &#123;                            next = e.next;                            if ((e.hash &amp; oldCap) == 0) &#123;                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            &#125;                            else &#123;                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            &#125;                        &#125; while ((e = next) != null);                        if (loTail != null) &#123;                            loTail.next = null;                            newTab[j] = loHead;                        &#125;                        if (hiTail != null) &#123;                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return newTab;    &#125;\n这个方法是扩容和初始化。主要看一下newTab[e.hash &amp; (newCap - 1)]和(e.hash &amp; oldCap) == 0第一个上面说了，只不过是重新计算了下key在数组的位置，先看第二个(e.hash &amp; oldCap) == 0，oldCap是旧数组的长度16(10000)，a&amp;10000只有地五位是0的情况下结果才是0，原来取了后四位判断key所在的位置，现在扩容往左多移了一位自然要把原来这个链表拆成第五位是1和0的两种情况，并重新计算位置。如果第五位是0和新的数组长度31(11111)做&amp;运算依然是0，位置不变，如果是1，假设原来在1111这个位置下角标15，而现在是31(11111)，其中是多了一个扩容的长度16\n这里说一个我认为比较矛盾的地方，当他判断只有一个节点没有链表的时候重新计算了地址，但是后面是通过判断扩容的位置是0和1的情况再进行地址的调整，如果说后者比前者效率更高的话可以把前面也改成先判断再调整位置，直接计算效率效率高的话也可以dowhile遍历同时计算位置然后赋值。知道答案的小伙伴可以给我解惑下\n"}]