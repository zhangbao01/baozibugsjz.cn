## zk分布式锁

1. 简单版本
   - 获取锁的节点成功在zk中创建临时目录
   - 获取锁失败的节点等待,注册watch监听临时节点删除后唤醒节点去获取锁
2. 顺序节点获取锁
   - 获取锁在zk中创建一个临时顺序节点
   - 获取锁失败同理创建一个顺序节点同时监听前一个顺序节点
   - watch监听到事件后判断自己是否是第一个节点则获取锁成功

## redis

1. 简单版本:
   - set ex nx方式,当key存在时返回nil代表获取锁失败,key不存在返回成功获取锁成功
   - 锁的超时时间为ex
   - 释放锁lua脚本 get+del
   - 存在问题:
     - redis主从切换时锁丢失问题导致不互斥  
     - ex:当获取锁的线程还未执行完时锁过期,导致不互斥,比如下游服务调用超时或jvm gc停顿
     - get+del需要保证原子性操作防止释放别的线程持有锁
2. redlock:
   - 客户端根据key和随机value同时去5个master节点获取锁信息,包含总的获取锁超时时间
   - 当大多数节点获取锁成功后判断当前获取锁的耗时和超时时间对比,耗时小则获取锁成功
   - 否则释放之前获取成功的锁,等待下一次再去获取锁
   - 存在问题:
     - 比如获取锁成功但客户端还未收到响应,当客户端收到响应时锁过期了;客户端b获取锁成功,导致不互斥
3. fencing 栅栏方式
   - 每个client获取锁时拿一个token值,token值递增
   - 比如client1:获取锁成功拿到token:31 此时client1 gc
   - client2:获取到锁拿到token:32  
   - gc 完成client1活过来写数据的时候存储层校验token的值发现31<32则拒绝写入
4. 最佳方案:redisson
  - lock(默认30s)+lock  watch dog(看门狗,每10s 过期时间重置为30s)
  - lock(timeout):支持超时的获取锁
  - 可重入锁等功能