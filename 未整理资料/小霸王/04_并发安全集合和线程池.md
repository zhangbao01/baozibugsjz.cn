## CopyOnWriteArrayList

1. 初始化
   - Lock:非公平锁
   - volatile修饰的array数组 默认为容量为0的object类型数组
2. add操作:
   - 加锁
   - 生成一个新的数组将旧数组的数据拷贝过来
   - 替换就的数组
   - 释放锁
3. get和size操作
   - 不加锁
4. iterator
   - 对快照版本的数据迭代
5. 适合读多写少的场景
   - 自研分布式文件系统中内存维护已刷入磁盘的editlog的list,backupNode每隔一段时间来fetch editlog
   - rocketmq中MappedFileQueue创建mappedFile和读取mappedFile来根据offset查询对应的commitlog



## ConcurrentLinkedQueue

1. 初始化

   - 单向链表node节点,包含item和next
   - head=tail=空节点(item元素为空),通过volatile修饰来保证修改后其他线程第一时间可见

2. add等价offer无锁cas尾部入队

   - 当tail.next==null时直接cas添加到尾部 此时head=tail=null  比如 null->11

   - tail.next!=null时先找到尾结点然后尾部cas操作 null->11->12 此时head=null tail=12

   - 原理图

     ![image-20200716194642355](https://note.youdao.com/yws/api/personal/file/WEB0e3ba131f34ef738ac512fa9761c77ee?method=download&shareKey=c65cf4d0f88fa4028d67fe1d98e12d2c)

3. poll:无锁头部出队

   - 头部出队列cas更新值为null

   - 更新头节点 null的节点next指向自己

   - 原理图

     ![image-20200716194731136](https://note.youdao.com/yws/api/personal/file/WEBa18b5db98582bfc2068fe3fceb9f965d?method=download&shareKey=447cfe6d4f77434d8d380ac9abcbb233)

4. peek:获取头节点元素

5. size:从头遍历到位,前后可能数据不一致 volatile来保证可见性

6. constains:判断元素是否存在,可能数据不一致 volatile来保证可见性

7. remove:cas来删除

8. iterator:迭代无锁可能会插入元素 volatile来保证可见性

9. 应用场景:

   - eureka-server三层队列集群同步信息第一层队列



## LinkedBlockingQueue

1. 初始化

   - 单向链表 node(item和next)
   - head和last初始化为null
   - takeLock(非公平锁)+notEmpty(队列不为空的condition等待队列)
   - putLock(非公平锁)+notFull(队列不满的condition等待队列)
   - capacity:初始化容量 默认为Integer.max_value
   - count:atomicInteger cas队列中元素个数 因为put和take操作不互斥

2. add或offer入队操作不阻塞等待

3. put操作队列满是阻塞

   - 原理图

     ![image-20200716195338728](https://note.youdao.com/yws/api/personal/file/WEBa8a9efd38859a5a23be581d39edbc7f4?method=download&shareKey=2d24847524a2d02ac9cfa7545d3a1c8f)

4. poll操作无元素返回null 不阻塞等待

5. take操作阻塞等待

   - 原理图

     ![image-20200716195530973](https://note.youdao.com/yws/api/personal/file/WEB8da379250d5b1684a816fa87aa316b1a?method=download&shareKey=192b35b1a04b9513ba073bb944c87980)

   

   - contains:元素是否存在 putLock和takeLock两把锁
   - iterator:putLock和takeLock的方式来遍历
   - 应用场景:
  - eureka-server集群同步第二层和第三层队列
     - kafkaRequestHandler处理完请求后放入到processor线程id对应的响应队列中
   
   

## ArrayBlockingQueue

1. 初始化

   - 有参构造指定capacity的大小
   - item:按容量初始化数组
   - lock:根据fair参数老构建非公平锁或公平锁 默认非公平锁
   - notEmpty和notFull 队列不为空和队列不满的condition等待队列
   - putIndex:保存当前put操作对应的数组下标
   - takeIndex:保存当前take操作出数组的下标
   - count:数组中元素个数(普通int类型 因为put和take操作是互斥的)

2. add和offer:当队列满时添加失败不阻塞

3. put操作:阻塞

   - 原理图

     ![image-20200716200732162](https://note.youdao.com/yws/api/personal/file/WEB9a95f88842be554387cc52fcaffc7720?method=download&shareKey=f8c062a560fee18c75250fcc69323272)

4. poll操作:队列为空返回null 不阻塞等待

5. take操作:阻塞等待原理图如上

6. size:获取锁查询count

7. constains:获取锁遍历从takeIndex到putIndex结束

8. iterator:迭代获取元素 阻塞加锁



## PriorityBlockingQueue

1. 初始化

   - queue:默认数组容量为11的数组 无限扩容
   - comparator:比较器(比较数组中元素的大小进行排序存储)
   - lock:非公平锁 notEmpty:队列不为空的condition等待队列

2. 原理图

   ![image-20200716204159142](https://note.youdao.com/yws/api/personal/file/WEBfa61c5124b68034305aedebbdd9150d3?method=download&shareKey=00cc22c4833e7080d8be4892a6d52645)



## ThreadPoolExecutor

1. 初始化
   - corePoolSize:核心线程数
   - maxinumPoolSize:最大线程数
   - workQueue:阻塞队列
   - keepAliveTime:非核心线程poll拉去任务获取不到闲置多久后被销毁
   - unit:时间单位
   - threadFactory:初始化线程的工厂
   - handler:线程拒绝任务的handler
     - AbortPolicy:默认拒绝抛出RejectedExcutionException异常
     - DiscardPolicy:丢弃不处理
     - DiscardOldestPolicy:从阻塞队列中poll一个元素后提交当前线程执行
     - CallerRunsPolicy:直接执行
2. excutors创建线程池的方式
   - newFixedThreadPool:核心线程==最大线程=指定大小,使用LinkedBlockingQueue:无界
   - newCachedThreadPool:核心线程0,最大线程Integer.Max_value 空闲:60s 队列:SynchronousQueue
   - newSignleThreadPool:核心线程=最大线程=1 使用:LinkedBlockingQueue:无界
   - newScheduleThreadPool:核心线程=指定大小 最大线程=integer.max_value 队列:DelayWorkQueue
3. 原理图
   - ![image-20200716204425731](https://note.youdao.com/yws/api/personal/file/WEBe24881346cc36d9296a2060fd9f1d5fe?method=download&shareKey=770edabd46621621d0c66e5a48a8a33b)
   - ![image-20200716204519751](https://note.youdao.com/yws/api/personal/file/WEB9b5b8c5677af440c602f24d9b0ae1d94?method=download&shareKey=7465ca1cb142f63a2429cad9e99b5b2c)
4. 非核心线程退出:
   - 当第一次poll(timeout)获取失败,进入下一次循环
   - 判断队列是否为空,为空则获取返回null交给proceeWorkerExist方法来退出
5. 线程执行任务异常退出
6. shutdown
   - 修改线程状态为shutdown
   - 拒绝新提交的任务
   - 中断未在执行任务的线程即state=0还未获取lock锁来执行线程
   - 优点:会将队列中的任务执行完成或正在运行的任务
7. shutdownNow
   - 修改线程的状态为stop
   - 拒绝新提交的任务
   - 中断state>=0的线程即不包括worker创建未开启的线程,队列中的元素取出来后当结果值返回
8. shutdown和shutdown相同点
   - 都不会销毁addWorker中还未启动的线程即state=-1
   - 都会将线程启动了但是线程本身持有的firstTask还未执行的线程销毁
   - 都会拒绝新提交的任务