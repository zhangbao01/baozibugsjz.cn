## 过期时间

1. 过期时间设置

   - 秒:expire key 100  
   - 毫秒:pexpire key 100 
   - 指定秒:expireat key 23423423423
   - 指定毫秒:pexpireat key 23423423423000 
   
2. 底层实现转为pexpireat

   - expire key 100
   - 转毫秒:expire key 100000
   - 计算指定毫秒值:100000+now()=11111100000
   - 设置过期时间:pexpireat key 11111100000
   
3. 通过ttl来查看时间

   - ttl key或pttl key
   - 当key不存在返回-2
   - key存在key没有设置过期时间返回-1
   - key还未过期返回对应的时间,key过期了返回-2或-1根据key是否存在来判断
   
4. 删除过期时间:persist message

   

## 过期策略

1. 定时删除:通过配置timer定时器,当key到某个时间点过期时自动删除
   - 缺点:当内存够用时,某个时间点过期key特别多此时cpu需要来处理过期key影响客户端的写入性能
   - redis中时间定时器实现为无序链表,查看一个事件为O(N)不能高效处理大量时间
2. 定期删除

   - 在指定时间内去轮询db,记录每次检查删除到的db位置(方便下次从那个开始)
   - 每个db中随机获取带有过期时间的key,默认每个数据库每次删除20个后轮到下一个db,如果db无过期key跳过
   - 删除一遍db后记录当前数据db位置的计数器重置当前删除的db为0
3. 惰性删除:当客户端获取当前key的值时进行判断
   - 判断当前key是否存在,不存在直接返回nil
   - 当前key存在,判断expire字典是否存在当前key,不存在则返回数据
   - 存在,判断key是否过期比较当前时间和过期时间,返回对应的过期情况如果过期了则回收(即惰性删除)
4. 回收池:当使用lru方式去淘汰key的数据的时候,回收池16,从小到大的顺序来存储要淘汰的key(空闲时间排序),当内存不够使用时,则随机从redisdb过期字典中随机选择server.maxmemory_samples 个键,放入到回收池中可能存在情况如下
   - 回收池满了,当前key的空闲时间比回收池末尾值小则不加入
   - 回收池满了,比末尾值大找到对应key的存储位置向后移动一个位置即最大值的key被淘汰了,插入到指定key位置
   - 回收池未满,能找到key存储的位置,移动后插入
   - 回收池未满,不能找到key存储的位置,末尾插入
   



## 内存淘汰策略

1. noeviction:内存满后不让写报错(默认配置)
2. allkeys-lru:对所有的key执行lru淘汰
3. volatile-lru:过期key进行lru淘汰
4. allkeys-random:所有key进行随机删除
5. allkeys-lru:所有key进行lru
6. volatile-ttl:删除过期时间空间中,有更早过期时间的key